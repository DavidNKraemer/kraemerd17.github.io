
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass{article}

    
    
    \usepackage{graphicx} % Used to insert images
    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{color} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    

    
    
    \definecolor{orange}{cmyk}{0,0.4,0.8,0.2}
    \definecolor{darkorange}{rgb}{.71,0.21,0.01}
    \definecolor{darkgreen}{rgb}{.12,.54,.11}
    \definecolor{myteal}{rgb}{.26, .44, .56}
    \definecolor{gray}{gray}{0.45}
    \definecolor{lightgray}{gray}{.95}
    \definecolor{mediumgray}{gray}{.8}
    \definecolor{inputbackground}{rgb}{.95, .95, .85}
    \definecolor{outputbackground}{rgb}{.95, .95, .95}
    \definecolor{traceback}{rgb}{1, .95, .95}
    % ansi colors
    \definecolor{red}{rgb}{.6,0,0}
    \definecolor{green}{rgb}{0,.65,0}
    \definecolor{brown}{rgb}{0.6,0.6,0}
    \definecolor{blue}{rgb}{0,.145,.698}
    \definecolor{purple}{rgb}{.698,.145,.698}
    \definecolor{cyan}{rgb}{0,.698,.698}
    \definecolor{lightgray}{gray}{0.5}
    
    % bright ansi colors
    \definecolor{darkgray}{gray}{0.25}
    \definecolor{lightred}{rgb}{1.0,0.39,0.28}
    \definecolor{lightgreen}{rgb}{0.48,0.99,0.0}
    \definecolor{lightblue}{rgb}{0.53,0.81,0.92}
    \definecolor{lightpurple}{rgb}{0.87,0.63,0.87}
    \definecolor{lightcyan}{rgb}{0.5,1.0,0.83}
    
    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{Getting Started with \texttt{Pandas}}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=blue,
      linkcolor=darkorange,
      citecolor=darkgreen,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \section{\texttt{Pandas} in a nutshell}\label{pandas-in-a-nutshell}

    \texttt{Pandas} is the \texttt{Python} library designed specifically for
data analysis. The author of \emph{Python for Data Analysis}, Wes
McKinney, began developing \texttt{Pandas} in 2008

\begin{quote}
while at \href{http://en.wikipedia.org/wiki/AQR_Capital}{AQR Capital
Management} out of need for a performant, flexible tool to perform
quantitative analysis on financial data. Before leaving AQR he was able
to convince management to allow him to open source the library.
\end{quote}

\begin{quote}
Another AQR employee, Chang She, joined the effort in 2012 as the second
major contributor to the library. Right around that time, the library
became popular in the \texttt{Python} community, and many more
contributors joined the project making it one of the most vital and
active data analysis libraries for \texttt{Python}.
(\href{http://en.wikipedia.org/wiki/Pandas_(software)}{Wikipedia}
\end{quote}

\texttt{Pandas} can be thought of the \texttt{Python} equivalent of
Microsoft Excel. It abstracts the notion of the spreadsheet, allowing
the user to use powerful and robust analytical tools generally to
automate repeated processes.

The twin centerpieces of the \texttt{Pandas} library are the
\texttt{Series} and the \texttt{DataFrame}. The \texttt{Series} class
is, at its core, a one-dimensional \texttt{NumPy} array, surrounded by
additional information, such as its index. The \texttt{DataFrame} is
conceptually an \emph{array} of \texttt{Series} classes, each sharing
the same index.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{k+kn}{from} \PY{n+nn}{pandas} \PY{k+kn}{import} \PY{n}{Series}\PY{p}{,} \PY{n}{DataFrame}
        \PY{k+kn}{import} \PY{n+nn}{pandas} \PY{k+kn}{as} \PY{n+nn}{pd}
\end{Verbatim}

    We will be using Wes McKinney's
\href{https://github.com/pydata/pydata-book/blob/master/ch05.ipynb}{GitHub
notebook} as a skeleton. He imports the following libraries for later
use:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{k+kn}{from} \PY{n+nn}{\PYZus{}\PYZus{}future\PYZus{}\PYZus{}} \PY{k+kn}{import} \PY{n}{division}
        \PY{k+kn}{from} \PY{n+nn}{numpy.random} \PY{k+kn}{import} \PY{n}{randn}
        \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k+kn}{as} \PY{n+nn}{np}
        \PY{k+kn}{import} \PY{n+nn}{os}
        \PY{k+kn}{import} \PY{n+nn}{matplotlib.pyplot} \PY{k+kn}{as} \PY{n+nn}{plt}
        \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{seed}\PY{p}{(}\PY{l+m+mi}{12345}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{rc}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{figure}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{n}{figsize}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}
        \PY{k+kn}{from} \PY{n+nn}{pandas} \PY{k+kn}{import} \PY{n}{Series}\PY{p}{,} \PY{n}{DataFrame}
        \PY{k+kn}{import} \PY{n+nn}{pandas} \PY{k+kn}{as} \PY{n+nn}{pd}
        \PY{n}{np}\PY{o}{.}\PY{n}{set\PYZus{}printoptions}\PY{p}{(}\PY{n}{precision}\PY{o}{=}\PY{l+m+mi}{4}\PY{p}{)}
\end{Verbatim}

    \section{Introduction to pandas data
structures}\label{introduction-to-pandas-data-structures}

    \subsection{Series}\label{series}

    Consider the following input:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{n}{obj} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{7}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
        \PY{n}{obj}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}3}]:} 0    4
        1    7
        2   -5
        3    3
        dtype: int64
\end{Verbatim}
        
    We have set the variable \texttt{obj} to reference a new
\texttt{Pandas Series}, which we initialized by giving a \texttt{Python}
list as input. Notice that \texttt{Pandas} automatically interprets the
input data as type \texttt{int64}, which indicates that it is fairly
smart! Also, notice that upon printing \texttt{obj} we see \emph{two}
columns. The first column is the \emph{index} of the \texttt{Series}
class, which is presently the natural index, \texttt{range(4)}. The
second column is the input data that we gave initially, which
\texttt{Pandas} refers to as the \emph{values} of \texttt{obj}. You can
access these columns individualy by calling \texttt{obj.index} and
\texttt{obj.values}, respectively. For example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{k}{print} \PY{n}{obj}\PY{o}{.}\PY{n}{index}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+se}{\PYZbs{}n}\PY{l+s}{\PYZdq{}}
        \PY{k}{print} \PY{n}{obj}\PY{o}{.}\PY{n}{values}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Int64Index([0, 1, 2, 3], dtype='int64') 


[ 4  7 -5  3]
    \end{Verbatim}

    \subsubsection{Indexing}\label{indexing}

As previously mentioned, the natural index simply starts at 0 and
increments integers to the size of the list of the input values.
Alternatively, we can specify the index explicitly when we initialize
the \texttt{Series}, as in the following:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{n}{obj2} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{7}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
        \PY{n}{obj2}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}5}]:} d    4
        b    7
        a   -5
        c    3
        dtype: int64
\end{Verbatim}
        
    What happens when you examine the index now?

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{n}{obj2}\PY{o}{.}\PY{n}{index}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}6}]:} Index([u'd', u'b', u'a', u'c'], dtype='object')
\end{Verbatim}
        
    Don't be alarmed by the \texttt{u} prefix to each of the index values.
In \texttt{Python} (as well as in other languages, this simply indicates
a
\href{http://stackoverflow.com/questions/2464959/whats-the-u-prefix-in-a-python-string}{Unicode
string}. Ostensibly, there is no difference between normal strings and
Unicode strings.

You can access a particular member of the \texttt{Series} data by
specifying its index. For example,

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{n}{obj2}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}7}]:} -5
\end{Verbatim}
        
    This allows you to change the value of specific entries in your
\texttt{Series} data. Additionally, you can call
\emph{sub}\texttt{Series} by specifying a sublist of the index.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{n}{obj2}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{6}
        \PY{n}{obj2}\PY{p}{[}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}8}]:} c    3
        a   -5
        d    6
        dtype: int64
\end{Verbatim}
        
    A powerful tool in \texttt{Pandas} is the ability to concisely access
data meeting \texttt{Boolean} qualifications. In the case below,
\texttt{obj2 \textgreater{} 0} is given as the ``index,'' and the output
is the sub\texttt{Series} of \texttt{obj2} for which all entries are
positive.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{n}{obj2}\PY{p}{[}\PY{n}{obj2} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}9}]:} d    6
        b    7
        c    3
        dtype: int64
\end{Verbatim}
        
    \subsubsection{Aside}\label{aside}

What is \texttt{obj2 \textgreater{} 0} actually?

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{n}{obj2} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}10}]:} d     True
         b     True
         a    False
         c     True
         dtype: bool
\end{Verbatim}
        
    This is actually a neat property of \texttt{Pandas} which is similar to
\texttt{NumPy}. In \texttt{NumPy}, suppose you are given an array:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{n}{arr} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)} \PY{o}{*} \PY{l+m+mf}{2.0} \PY{o}{\PYZhy{}} \PY{l+m+mf}{1.0}
\end{Verbatim}

    The actual array itself is given by

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{n}{arr}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}12}]:} array([ 0.8592, -0.3672, -0.6322, -0.5909,  0.1355])
\end{Verbatim}
        
    The \texttt{Boolean} array specifying which elements of \texttt{arr} are
positive is given by

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{n}{boolArr} \PY{o}{=} \PY{n}{arr} \PY{o}{\PYZgt{}} \PY{l+m+mf}{0.0}
         \PY{n}{boolArr}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}13}]:} array([ True, False, False, False,  True], dtype=bool)
\end{Verbatim}
        
    Similarly, you can generate a new \texttt{Series} of \texttt{Boolean}
values by subjecting the original \texttt{Series} to a \texttt{Boolean}
statement, as we did above.

\subsubsection{Broadcasting}\label{broadcasting}

Like \texttt{NumPy}, we can \emph{broadcast} arithmetic operations onto
\texttt{Series} data. For example,

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{n}{obj2} \PY{o}{*} \PY{l+m+mi}{2}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}14}]:} d    12
         b    14
         a   -10
         c     6
         dtype: int64
\end{Verbatim}
        
    returns a \texttt{Series} whose values are doubled, and

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{n}{np}\PY{o}{.}\PY{n}{exp}\PY{p}{(}\PY{n}{obj2}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}15}]:} d     403.428793
         b    1096.633158
         a       0.006738
         c      20.085537
         dtype: float64
\end{Verbatim}
        
    returns a \texttt{Series} whose values have all been subject to the
transformation $x\mapsto e^x$. Notice additionally that the
\texttt{dtype} of \texttt{obj2} has automatically been changed from
\texttt{int64} to \texttt{float64}. Again, \texttt{Pandas} is being
smart!

    \subsubsection{Querying a \texttt{Series}}\label{querying-a-series}

    In \texttt{Python}, there is a binary operator called \texttt{in}, which
takes two ``arguments.'' The left-hand argument is can be any type of
data (or object, we won't get into this), while the right-hand argument
is some type of iterable object. Then \texttt{in} returns \texttt{True}
if the left-hand argument is an \emph{element} of the right-hand
argument. Mathematically, this is equivalent to set membership. For
example,

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{n}{odds} \PY{o}{=} \PY{p}{[}\PY{n}{i} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{)} \PY{k}{if} \PY{n}{i}\PY{o}{\PYZpc{}}\PY{k}{2} == 1]
         \PY{k}{print} \PY{l+m+mi}{3} \PY{o+ow}{in} \PY{n}{odds}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{|}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{2} \PY{o+ow}{in} \PY{n}{odds}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
True | False
    \end{Verbatim}

    is equivalent to noting that if
\[\text{Odds} = \{ n : 0 \leq n < 20 \text{ and } n \text{ is odd}\}\]
we have that \[3 \in \text{Odds}\] while \[2 \notin \text{Odds}.\]

(In fact, we have already seen \texttt{in} in action with
\texttt{Python}'s \texttt{for} loop, which has the form

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{for} \NormalTok{element in iterative_object:}
\end{Highlighting}
\end{Shaded}

indicating that the code should loop through every element
\texttt{element} that is a member of \texttt{iterative\_object}.)

You can use \texttt{in} with \texttt{Pandas} \texttt{Series} to test
that an element is a member of the index of the \texttt{Series}. For
example,

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}} \PY{o+ow}{in} \PY{n}{obj2}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}17}]:} True
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}18}]:} \PY{l+s}{\PYZsq{}}\PY{l+s}{e}\PY{l+s}{\PYZsq{}} \PY{o+ow}{in} \PY{n}{obj2}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}18}]:} False
\end{Verbatim}
        
    \subsubsection{Aside}\label{aside}

We have talked about the native \texttt{Python} list data type. There is
another important native data type in \texttt{Python}, called a
\texttt{dict}, which you can learn about more
\href{http://www.codecademy.com/courses/python-beginner-en-pwmb1/2/1?curriculum_id=4f89dab3d788890003000096}{here}.
\texttt{Python} \texttt{dict} types are similar to association lists in
\texttt{Scheme}, in that they require a lookup key in order to access
elements.

Crucially, \texttt{Pandas} can create a \texttt{Series} from a
\texttt{dict} by interpreting the key for each item as its corresponding
index value, which is actually quite natural. In this sense, I find that
it is useful to think of the relationship between \texttt{NumPy} and
\texttt{Pandas} as akin to the relationship between a list and a
\texttt{dict}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} \PY{n}{sdata} \PY{o}{=} \PY{p}{\PYZob{}}\PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{35000}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Texas}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{71000}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Oregon}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{16000}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Utah}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{5000}\PY{p}{\PYZcb{}}
         \PY{n}{obj3} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{n}{sdata}\PY{p}{)}
         \PY{n}{obj3}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}19}]:} Ohio      35000
         Oregon    16000
         Texas     71000
         Utah       5000
         dtype: int64
\end{Verbatim}
        
    What happens when you use an existing dataset with a new index, in which
there is a new, unfilled index?

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}20}]:} \PY{n}{states} \PY{o}{=} \PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{California}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Oregon}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Texas}\PY{l+s}{\PYZsq{}}\PY{p}{]}
         \PY{n}{obj4} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{n}{sdata}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{n}{states}\PY{p}{)}
         \PY{n}{obj4}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}20}]:} California      NaN
         Ohio          35000
         Oregon        16000
         Texas         71000
         dtype: float64
\end{Verbatim}
        
    In this case, \texttt{California} is a previously-unused index, which
has no corresponding value. Thus, \texttt{Pandas} initializes the new
\texttt{Series} with the value corresponding to \texttt{California} set
to \texttt{NaN} (\texttt{Python}-speak for null).

The \texttt{isnull} method returns a \texttt{Series} of \texttt{Boolean}
values whenever the original \texttt{Series} has a null (\texttt{NaN})
value.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}21}]:} \PY{n}{pd}\PY{o}{.}\PY{n}{isnull}\PY{p}{(}\PY{n}{obj4}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}21}]:} California     True
         Ohio          False
         Oregon        False
         Texas         False
         dtype: bool
\end{Verbatim}
        
    The \texttt{notnull} method does the exact opposite!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} \PY{n}{pd}\PY{o}{.}\PY{n}{notnull}\PY{p}{(}\PY{n}{obj4}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}22}]:} California    False
         Ohio           True
         Oregon         True
         Texas          True
         dtype: bool
\end{Verbatim}
        
    The methods \texttt{isnull} and \texttt{notnull} are ``static'' in the
sense that they can be called straight from the \texttt{pd} module or
for a specific \texttt{Series} object.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{n}{obj4}\PY{o}{.}\PY{n}{isnull}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}23}]:} California     True
         Ohio          False
         Oregon        False
         Texas         False
         dtype: bool
\end{Verbatim}
        
    Recall the two \texttt{Series}, \texttt{obj3} and \texttt{obj4}:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}24}]:} \PY{k}{print} \PY{l+s}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}t}\PY{l+s}{obj3:}\PY{l+s+se}{\PYZbs{}n}\PY{l+s}{\PYZdq{}}\PY{p}{,}\PY{n}{obj3}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+se}{\PYZbs{}t}\PY{l+s}{obj4:}\PY{l+s+se}{\PYZbs{}n}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{obj4}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
obj3:
Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64 

	obj4:
California      NaN
Ohio          35000
Oregon        16000
Texas         71000
dtype: float64
    \end{Verbatim}

    Arithmetic operations between distinct \texttt{Series} objects work
conservatively. For data types, \texttt{int64 + float64 = float64} to
preserve the decimal information. The summed index is the union of the
two indices. Consider the following example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}25}]:} \PY{n}{obj3} \PY{o}{+} \PY{n}{obj4}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}25}]:} California       NaN
         Ohio           70000
         Oregon         32000
         Texas         142000
         Utah             NaN
         dtype: float64
\end{Verbatim}
        
    No entry for \texttt{California} exists in \texttt{obj3}, while no entry
for \texttt{Utah} exists in \texttt{obj4}. \texttt{Pandas} interprets
\texttt{NaN + x = NaN} for all \texttt{x}, so the resultant
\texttt{Series} sets \texttt{NaN} for both \texttt{California} and
\texttt{Utah}.

    We can set some metadata for a \texttt{Series}, such as the name of the
values column and the name of the index column.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}26}]:} \PY{n}{obj4}\PY{o}{.}\PY{n}{name} \PY{o}{=} \PY{l+s}{\PYZsq{}}\PY{l+s}{population}\PY{l+s}{\PYZsq{}}
         \PY{n}{obj4}\PY{o}{.}\PY{n}{index}\PY{o}{.}\PY{n}{name} \PY{o}{=} \PY{l+s}{\PYZsq{}}\PY{l+s}{state}\PY{l+s}{\PYZsq{}}
         \PY{n}{obj4}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}26}]:} state
         California      NaN
         Ohio          35000
         Oregon        16000
         Texas         71000
         Name: population, dtype: float64
\end{Verbatim}
        
    You can also completely change the index at any time. This is something
we will get into more detail later.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}27}]:} \PY{n}{obj}\PY{o}{.}\PY{n}{index} \PY{o}{=} \PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Bob}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Steve}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Jeff}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Ryan}\PY{l+s}{\PYZsq{}}\PY{p}{]}
         \PY{n}{obj}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}27}]:} Bob      4
         Steve    7
         Jeff    -5
         Ryan     3
         dtype: int64
\end{Verbatim}
        
    \subsection{DataFrame}\label{dataframe}

    Like we said before, you can think of a \texttt{DataFrame} as an
\emph{array} of \texttt{Series} objects. Specifically, a
\texttt{DataFrame} is a two-dimensional array of \texttt{Series}
objects, all indexed by the same index series. You can also think of a
\texttt{DataFrame} as a single Microsoft Excel spreadsheet.

One way to initialize a \texttt{DataFrame} is by giving a \texttt{dict}
where each key indicates a \texttt{Python} list.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}28}]:} \PY{n}{data} \PY{o}{=} \PY{p}{\PYZob{}}\PY{l+s}{\PYZsq{}}\PY{l+s}{state}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Nevada}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Nevada}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                 \PY{l+s}{\PYZsq{}}\PY{l+s}{year}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+m+mi}{2000}\PY{p}{,} \PY{l+m+mi}{2001}\PY{p}{,} \PY{l+m+mi}{2002}\PY{p}{,} \PY{l+m+mi}{2001}\PY{p}{,} \PY{l+m+mi}{2002}\PY{p}{]}\PY{p}{,}
                 \PY{l+s}{\PYZsq{}}\PY{l+s}{pop}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+m+mf}{1.5}\PY{p}{,} \PY{l+m+mf}{1.7}\PY{p}{,} \PY{l+m+mf}{3.6}\PY{p}{,} \PY{l+m+mf}{2.4}\PY{p}{,} \PY{l+m+mf}{2.9}\PY{p}{]}\PY{p}{\PYZcb{}}
         \PY{n}{frame} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{data}\PY{p}{)}
         
         \PY{n}{frame}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}28}]:}    pop   state  year
         0  1.5    Ohio  2000
         1  1.7    Ohio  2001
         2  3.6    Ohio  2002
         3  2.4  Nevada  2001
         4  2.9  Nevada  2002
\end{Verbatim}
        
    You can reorder the columns in a new \texttt{DataFrame} using the
following argument:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}29}]:} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{data}\PY{p}{,} \PY{n}{columns}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{year}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{state}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{pop}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}29}]:}    year   state  pop
         0  2000    Ohio  1.5
         1  2001    Ohio  1.7
         2  2002    Ohio  3.6
         3  2001  Nevada  2.4
         4  2002  Nevada  2.9
\end{Verbatim}
        
    Similarly, the \texttt{index} optional argument in \texttt{DataFrame}
allows you to specify the index list. Additionally, adding a
\texttt{debt} column with no corresponding data in \texttt{data} will
initialize a column filled with \texttt{NaN} entries.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}30}]:} \PY{n}{frame2} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{data}\PY{p}{,} \PY{n}{columns}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{year}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{state}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{pop}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{debt}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                            \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{one}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{two}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{three}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{four}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{five}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{frame2}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}30}]:}        year   state  pop debt
         one    2000    Ohio  1.5  NaN
         two    2001    Ohio  1.7  NaN
         three  2002    Ohio  3.6  NaN
         four   2001  Nevada  2.4  NaN
         five   2002  Nevada  2.9  NaN
\end{Verbatim}
        
    You can access the columns of a \texttt{DataFrame} as follows:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}31}]:} \PY{n}{frame2}\PY{o}{.}\PY{n}{columns}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}31}]:} Index([u'year', u'state', u'pop', u'debt'], dtype='object')
\end{Verbatim}
        
    You can slice a particular column by specifying its column name. Notice
how this returns a \texttt{Series}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}32}]:} \PY{n}{frame2}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{state}\PY{l+s}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}32}]:} one        Ohio
         two        Ohio
         three      Ohio
         four     Nevada
         five     Nevada
         Name: state, dtype: object
\end{Verbatim}
        
    Alternatively, you can slice a column using the following syntax:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}33}]:} \PY{n}{frame2}\PY{o}{.}\PY{n}{year}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}33}]:} one      2000
         two      2001
         three    2002
         four     2001
         five     2002
         Name: year, dtype: int64
\end{Verbatim}
        
    To slice a row, you can specify an index, which will return a
\texttt{Series} representing the row at the index.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}34}]:} \PY{n}{frame2}\PY{o}{.}\PY{n}{ix}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{three}\PY{l+s}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}34}]:} year     2002
         state    Ohio
         pop       3.6
         debt      NaN
         Name: three, dtype: object
\end{Verbatim}
        
    Broadcasting works in the natural way that you might expect:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}35}]:} \PY{n}{frame2}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{debt}\PY{l+s}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{l+m+mf}{16.5}
         \PY{n}{frame2}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}35}]:}        year   state  pop  debt
         one    2000    Ohio  1.5  16.5
         two    2001    Ohio  1.7  16.5
         three  2002    Ohio  3.6  16.5
         four   2001  Nevada  2.4  16.5
         five   2002  Nevada  2.9  16.5
\end{Verbatim}
        
    You can also give a particular column a list or \texttt{ndarray}, which
will then be distributed across the column.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}36}]:} \PY{n}{frame2}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{debt}\PY{l+s}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mf}{5.}\PY{p}{)}
         \PY{n}{frame2}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}36}]:}        year   state  pop  debt
         one    2000    Ohio  1.5     0
         two    2001    Ohio  1.7     1
         three  2002    Ohio  3.6     2
         four   2001  Nevada  2.4     3
         five   2002  Nevada  2.9     4
\end{Verbatim}
        
    Finally, you can give a column of a \texttt{DataFrame} a
\texttt{Series}. If you specify a \texttt{Series} with an index
differing from the main \texttt{DataFrame}, then the entries of the
\texttt{DataFrame} will be set to \texttt{NaN}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}37}]:} \PY{n}{val} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mf}{1.2}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mf}{1.5}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mf}{1.7}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{two}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{four}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{five}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{frame2}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{debt}\PY{l+s}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{n}{val}
         \PY{n}{frame2}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}37}]:}        year   state  pop  debt
         one    2000    Ohio  1.5   NaN
         two    2001    Ohio  1.7  -1.2
         three  2002    Ohio  3.6   NaN
         four   2001  Nevada  2.4  -1.5
         five   2002  Nevada  2.9  -1.7
\end{Verbatim}
        
    The point of \texttt{Pandas} is there are \emph{numerous} ways to
achieve the same effect, depending on whatever is easiest for the task
at hand. Here is another way to add a column:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}38}]:} \PY{n}{frame2}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{eastern}\PY{l+s}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{n}{frame2}\PY{o}{.}\PY{n}{state} \PY{o}{==} \PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}
         \PY{n}{frame2}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}38}]:}        year   state  pop  debt eastern
         one    2000    Ohio  1.5   NaN    True
         two    2001    Ohio  1.7  -1.2    True
         three  2002    Ohio  3.6   NaN    True
         four   2001  Nevada  2.4  -1.5   False
         five   2002  Nevada  2.9  -1.7   False
\end{Verbatim}
        
    We can also use \texttt{Python}'s \texttt{del} function to remove a
column:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}39}]:} \PY{k}{del} \PY{n}{frame2}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{eastern}\PY{l+s}{\PYZsq{}}\PY{p}{]}
         \PY{n}{frame2}\PY{o}{.}\PY{n}{columns}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}39}]:} Index([u'year', u'state', u'pop', u'debt'], dtype='object')
\end{Verbatim}
        
    One final way to initialize \texttt{DataFrame} objects is with nested
\texttt{dict} objects.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}40}]:} \PY{n}{pop} \PY{o}{=} \PY{p}{\PYZob{}}\PY{l+s}{\PYZsq{}}\PY{l+s}{Nevada}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{p}{\PYZob{}}\PY{l+m+mi}{2001}\PY{p}{:} \PY{l+m+mf}{2.4}\PY{p}{,} \PY{l+m+mi}{2002}\PY{p}{:} \PY{l+m+mf}{2.9}\PY{p}{\PYZcb{}}\PY{p}{,}
                \PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{p}{\PYZob{}}\PY{l+m+mi}{2000}\PY{p}{:} \PY{l+m+mf}{1.5}\PY{p}{,} \PY{l+m+mi}{2001}\PY{p}{:} \PY{l+m+mf}{1.7}\PY{p}{,} \PY{l+m+mi}{2002}\PY{p}{:} \PY{l+m+mf}{3.6}\PY{p}{\PYZcb{}}\PY{p}{\PYZcb{}}
         
         \PY{n}{frame3} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{pop}\PY{p}{)}
         \PY{n}{frame3}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}40}]:}       Nevada  Ohio
         2000     NaN   1.5
         2001     2.4   1.7
         2002     2.9   3.6
\end{Verbatim}
        
    You can transpose a \texttt{DataFrame} if it makes more sense to work
with the rows and columns flipped.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}41}]:} \PY{n}{frame3}\PY{o}{.}\PY{n}{T}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}41}]:}         2000  2001  2002
         Nevada   NaN   2.4   2.9
         Ohio     1.5   1.7   3.6
\end{Verbatim}
        
    You can do this transpose operation from the outset by manually
specifying the index.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}42}]:} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{pop}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+m+mi}{2001}\PY{p}{,} \PY{l+m+mi}{2002}\PY{p}{,} \PY{l+m+mi}{2003}\PY{p}{]}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}42}]:}       Nevada  Ohio
         2001     2.4   1.7
         2002     2.9   3.6
         2003     NaN   NaN
\end{Verbatim}
        
    \texttt{DataFrame} objects can also be initialized from \texttt{dict}s
of \texttt{Series} objects.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}43}]:} \PY{n}{pdata} \PY{o}{=} \PY{p}{\PYZob{}}\PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{n}{frame3}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{[}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}
                  \PY{l+s}{\PYZsq{}}\PY{l+s}{Nevada}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{n}{frame3}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Nevada}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{[}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{\PYZcb{}}
         \PY{n}{DataFrame}\PY{p}{(}\PY{n}{pdata}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}43}]:}       Nevada  Ohio
         2000     NaN   1.5
         2001     2.4   1.7
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}44}]:} \PY{n}{frame3}\PY{o}{.}\PY{n}{index}\PY{o}{.}\PY{n}{name} \PY{o}{=} \PY{l+s}{\PYZsq{}}\PY{l+s}{year}\PY{l+s}{\PYZsq{}}\PY{p}{;} \PY{n}{frame3}\PY{o}{.}\PY{n}{columns}\PY{o}{.}\PY{n}{name} \PY{o}{=} \PY{l+s}{\PYZsq{}}\PY{l+s}{state}\PY{l+s}{\PYZsq{}}
         \PY{n}{frame3}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}44}]:} state  Nevada  Ohio
         year               
         2000      NaN   1.5
         2001      2.4   1.7
         2002      2.9   3.6
\end{Verbatim}
        
    If you need to access the underlying \texttt{ndarray} from any
\texttt{DataFrame}, use the \texttt{DataFrame.values} field.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}45}]:} \PY{n}{frame3}\PY{o}{.}\PY{n}{values}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}45}]:} array([[ nan,  1.5],
                [ 2.4,  1.7],
                [ 2.9,  3.6]])
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}46}]:} \PY{n}{frame2}\PY{o}{.}\PY{n}{values}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}46}]:} array([[2000, 'Ohio', 1.5, nan],
                [2001, 'Ohio', 1.7, -1.2],
                [2002, 'Ohio', 3.6, nan],
                [2001, 'Nevada', 2.4, -1.5],
                [2002, 'Nevada', 2.9, -1.7]], dtype=object)
\end{Verbatim}
        
    \subsection{Index objects}\label{index-objects}

    The \texttt{Index} is the ``metadata'' object for \texttt{Series} and
\texttt{DataFrame} objects. We've seen ways of initializing
\texttt{Index} objects before, so we will go over some features of these
objects.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}47}]:} \PY{n}{obj} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{index} \PY{o}{=} \PY{n}{obj}\PY{o}{.}\PY{n}{index}
         \PY{n}{index}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}47}]:} Index([u'a', u'b', u'c'], dtype='object')
\end{Verbatim}
        
    \texttt{Index} objects can be sliced like arrays.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}48}]:} \PY{n}{index}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}48}]:} Index([u'b', u'c'], dtype='object')
\end{Verbatim}
        
    Importantly, \texttt{Index} objects are not mutable, so you can't change
their values in the natural way:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}49}]:} \PY{n}{index}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]

        ---------------------------------------------------------------------------

        TypeError                                 Traceback (most recent call last)

        <ipython-input-49-676fdeb26a68> in <module>()
    ----> 1 index[1] = 'd'
    

        /home/alethiometryst/anaconda/lib/python2.7/site-packages/pandas/core/index.pyc in \_\_setitem\_\_(self, key, value)
        894 
        895     def \_\_setitem\_\_(self, key, value):
    --> 896         raise TypeError("Indexes does not support mutable operations")
        897 
        898     def \_\_getitem\_\_(self, key):


        TypeError: Indexes does not support mutable operations

    \end{Verbatim}

    You can initialize \texttt{Index} objects with \texttt{NumPy}
\texttt{ndarray} objects.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}50}]:} \PY{n}{index} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Index}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}
         \PY{n}{obj2} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mf}{1.5}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mf}{2.5}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{n}{index}\PY{p}{)}
         \PY{n}{obj2}\PY{o}{.}\PY{n}{index} \PY{o+ow}{is} \PY{n}{index}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}50}]:} True
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}51}]:} \PY{n}{frame3}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}51}]:} state  Nevada  Ohio
         year               
         2000      NaN   1.5
         2001      2.4   1.7
         2002      2.9   3.6
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}52}]:} \PY{k}{print} \PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}} \PY{o+ow}{in} \PY{n}{frame3}\PY{o}{.}\PY{n}{columns}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{|}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{2003} \PY{o+ow}{in} \PY{n}{frame3}\PY{o}{.}\PY{n}{index}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
True | False
    \end{Verbatim}

    \section{Essential functionality}\label{essential-functionality}

    Now that we are familiar with the basic objects in \texttt{Pandas}, we
will start working with the mechanics of these objects.

    \subsection{Reindexing}\label{reindexing}

    In the previous section we mentioned that \texttt{Index} objects are
immutable. Here we will address this issue.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}53}]:} \PY{n}{obj} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mf}{4.5}\PY{p}{,} \PY{l+m+mf}{7.2}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mf}{5.3}\PY{p}{,} \PY{l+m+mf}{3.6}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{obj}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}53}]:} d    4.5
         b    7.2
         a   -5.3
         c    3.6
         dtype: float64
\end{Verbatim}
        
    The simplest way to change an \texttt{Index} object in an existing
\texttt{Series} or \texttt{DataFrame} is with the \texttt{reindex}
method.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}54}]:} \PY{n}{obj2} \PY{o}{=} \PY{n}{obj}\PY{o}{.}\PY{n}{reindex}\PY{p}{(}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{e}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{obj2}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}54}]:} a   -5.3
         b    7.2
         c    3.6
         d    4.5
         e    NaN
         dtype: float64
\end{Verbatim}
        
    In the above example, since \texttt{"e"} was not in the original
\texttt{Index}, the corresponding \texttt{Series} value is set to
\texttt{NaN}. If you want to change the default fill value,
\texttt{reindex} can take an additional parameter, \texttt{fill\_value}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}55}]:} \PY{n}{obj}\PY{o}{.}\PY{n}{reindex}\PY{p}{(}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{e}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{n}{fill\PYZus{}value}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}55}]:} a   -5.3
         b    7.2
         c    3.6
         d    4.5
         e    0.0
         dtype: float64
\end{Verbatim}
        
    A different approach uses a \texttt{method} parameter that attempts to
extrapolate existing data into the new \texttt{Index}. One such method
is \texttt{ffill}, which ``step-fills'' the existing data forward.
Alternatively, \texttt{bfill} ``step-fills'' the data backwards.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}56}]:} \PY{n}{obj3} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{blue}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{purple}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{yellow}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{]}\PY{p}{)}
         \PY{n}{obj3}\PY{o}{.}\PY{n}{reindex}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{,} \PY{n}{method}\PY{o}{=}\PY{l+s}{\PYZsq{}}\PY{l+s}{ffill}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}56}]:} 0      blue
         1      blue
         2    purple
         3    purple
         4    yellow
         5    yellow
         dtype: object
\end{Verbatim}
        
    The \texttt{reindex} method works for \texttt{DataFrame} objects as
well. For \texttt{DataFrame} objects, \texttt{reindex} can also specify
column reindexing.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}57}]:} \PY{n}{frame} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mi}{9}\PY{p}{)}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                           \PY{n}{columns}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Texas}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{California}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{frame}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}57}]:}    Ohio  Texas  California
         a     0      1           2
         c     3      4           5
         d     6      7           8
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}58}]:} \PY{n}{frame}\PY{o}{.}\PY{n}{reindex}\PY{p}{(}\PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{n}{method}\PY{o}{=}\PY{l+s}{\PYZsq{}}\PY{l+s}{ffill}\PY{l+s}{\PYZsq{}}\PY{p}{,}
                       \PY{n}{columns}\PY{o}{=}\PY{n}{states}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}58}]:}    California  Ohio  Oregon  Texas
         a           2     0     NaN      1
         b           2     0     NaN      1
         c           5     3     NaN      4
         d           8     6     NaN      7
\end{Verbatim}
        
    Alternatively, you can use \texttt{ix} to achieve the same effect more
concisely.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}59}]:} \PY{n}{frame}\PY{o}{.}\PY{n}{ix}\PY{p}{[}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{n}{states}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}59}]:}    California  Ohio  Oregon  Texas
         a           2     0     NaN      1
         b         NaN   NaN     NaN    NaN
         c           5     3     NaN      4
         d           8     6     NaN      7
\end{Verbatim}
        
    \subsection{Dropping entries from an
axis}\label{dropping-entries-from-an-axis}

    Suppose you have a \texttt{Series} object with data you wish to remove.
Using the \texttt{drop} method, you can specify an index element to
remove.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}60}]:} \PY{n}{obj} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mf}{5.}\PY{p}{)}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{e}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{new\PYZus{}obj} \PY{o}{=} \PY{n}{obj}\PY{o}{.}\PY{n}{drop}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{)}
         \PY{n}{new\PYZus{}obj}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}60}]:} a    0
         b    1
         d    3
         e    4
         dtype: float64
\end{Verbatim}
        
    You can also drop a list of index elements at once.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}61}]:} \PY{n}{obj}\PY{o}{.}\PY{n}{drop}\PY{p}{(}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}61}]:} a    0
         b    1
         e    4
         dtype: float64
\end{Verbatim}
        
    The same works for \texttt{DataFrame} objects and the \texttt{drop}
method.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}62}]:} \PY{n}{data} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mi}{16}\PY{p}{)}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)}\PY{p}{)}\PY{p}{,}
                          \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Colorado}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Utah}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{New York}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                          \PY{n}{columns}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{one}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{two}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{three}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{four}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}63}]:} \PY{n}{data}\PY{o}{.}\PY{n}{drop}\PY{p}{(}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Colorado}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}63}]:}           one  two  three  four
         Utah        8    9     10    11
         New York   12   13     14    15
\end{Verbatim}
        
    Additionally, \texttt{DataFrame.drop()} can remove columns by specifying
an \texttt{axis} parameter.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}64}]:} \PY{n}{data}\PY{o}{.}\PY{n}{drop}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{two}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{n}{axis}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}64}]:}           one  three  four
         Ohio        0      2     3
         Colorado    4      6     7
         Utah        8     10    11
         New York   12     14    15
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}65}]:} \PY{n}{data}\PY{o}{.}\PY{n}{drop}\PY{p}{(}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{two}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{four}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{n}{axis}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}65}]:}           one  three
         Ohio        0      2
         Colorado    4      6
         Utah        8     10
         New York   12     14
\end{Verbatim}
        
    \subsection{Indexing, selection, and
filtering}\label{indexing-selection-and-filtering}

    In this section we will explore the various techniques available for
slicing \texttt{Series} and \texttt{DataFrame} objects. One the one
hand, we can deal with these objects as \texttt{dict} structures,
accessing elements by requesting their index keys. On the other hand, we
can treat these objects as list structures, accessing elements by the
order of the index list.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}66}]:} \PY{n}{obj} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mf}{4.}\PY{p}{)}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{obj}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}66}]:} 1.0
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}67}]:} \PY{n}{obj}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}67}]:} 1.0
\end{Verbatim}
        
    This flexibility allows you to incorporate all of the previous array
slicing that worked for \texttt{NumPy ndarray} objects.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}68}]:} \PY{n}{obj}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{:}\PY{l+m+mi}{4}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}68}]:} c    2
         d    3
         dtype: float64
\end{Verbatim}
        
    Conversely, you can use a list of \texttt{dict} keys to achieve the same
end.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}69}]:} \PY{n}{obj}\PY{p}{[}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}69}]:} b    1
         a    0
         d    3
         dtype: float64
\end{Verbatim}
        
    Here are some alternative slicing techniques for \texttt{Series}
objects.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}70}]:} \PY{n}{obj}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}70}]:} b    1
         d    3
         dtype: float64
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}71}]:} \PY{n}{obj}\PY{p}{[}\PY{n}{obj} \PY{o}{\PYZlt{}} \PY{l+m+mi}{2}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}71}]:} a    0
         b    1
         dtype: float64
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}72}]:} \PY{n}{obj}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{:}\PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}72}]:} b    1
         c    2
         dtype: float64
\end{Verbatim}
        
    You can assign values to sub-objects which then reflect on the original
object.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}73}]:} \PY{n}{obj}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{:}\PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{5}
         \PY{n}{obj}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}73}]:} a    0
         b    5
         c    5
         d    3
         dtype: float64
\end{Verbatim}
        
    The same capabilities are extended to the \texttt{DataFrame} objects.
The added flexibility is that the same indexing techniques also apply to
column slicing as well as index slicing.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}74}]:} \PY{n}{data} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mi}{16}\PY{p}{)}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)}\PY{p}{)}\PY{p}{,}
                          \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Colorado}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Utah}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{New York}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                          \PY{n}{columns}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{one}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{two}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{three}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{four}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{data}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}74}]:}           one  two  three  four
         Ohio        0    1      2     3
         Colorado    4    5      6     7
         Utah        8    9     10    11
         New York   12   13     14    15
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}75}]:} \PY{n}{data}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{two}\PY{l+s}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}75}]:} Ohio         1
         Colorado     5
         Utah         9
         New York    13
         Name: two, dtype: int64
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}76}]:} \PY{n}{data}\PY{p}{[}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{three}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{one}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}76}]:}           three  one
         Ohio          2    0
         Colorado      6    4
         Utah         10    8
         New York     14   12
\end{Verbatim}
        
    The natural slicing will always refer to the index list, not the column
list, which is useful to keep in mind.

data{[}:2{]}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}77}]:} \PY{n}{data}\PY{p}{[}\PY{n}{data}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{three}\PY{l+s}{\PYZsq{}}\PY{p}{]} \PY{o}{\PYZgt{}} \PY{l+m+mi}{5}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}77}]:}           one  two  three  four
         Colorado    4    5      6     7
         Utah        8    9     10    11
         New York   12   13     14    15
\end{Verbatim}
        
    Recall that you can generate a corresponding \texttt{Boolean} array by
subjecting a \texttt{DataFrame} to a boolean statement, such as the
following:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}78}]:} \PY{n}{data} \PY{o}{\PYZlt{}} \PY{l+m+mi}{5}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}78}]:}             one    two  three   four
         Ohio       True   True   True   True
         Colorado   True  False  False  False
         Utah      False  False  False  False
         New York  False  False  False  False
\end{Verbatim}
        
    You can use \texttt{Boolean} arrays to do simple thresholding to your
data. You can isolate entries in your data subject to identical
\texttt{Boolean} conditions, and manipulate these specific subsets of
the data.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}79}]:} \PY{n}{data}\PY{p}{[}\PY{n}{data} \PY{o}{\PYZlt{}} \PY{l+m+mi}{5}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{0}
         \PY{n}{data}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}79}]:}           one  two  three  four
         Ohio        0    0      0     0
         Colorado    0    5      6     7
         Utah        8    9     10    11
         New York   12   13     14    15
\end{Verbatim}
        
    The \texttt{DataFrame.ix} field gives you even more powerful ways to
slice your data. In general, slicing works by providing two arguments,
an index and a column specification, and it will then return that
particular subset.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}80}]:} \PY{n}{data}\PY{o}{.}\PY{n}{ix}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Colorado}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{two}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{three}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}80}]:} two      5
         three    6
         Name: Colorado, dtype: int64
\end{Verbatim}
        
    You can overload requests by using a list of index or column elements.
Additionally, you may reorder the indices or columns in your subset by
permuting the order of the specified elements, so long as they exist in
the original \texttt{DataFrame}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}81}]:} \PY{n}{data}\PY{o}{.}\PY{n}{ix}\PY{p}{[}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Colorado}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Utah}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}81}]:}           four  one  two
         Colorado     7    0    5
         Utah        11    8    9
\end{Verbatim}
        
    The \texttt{ix} approach is very powerful. See if you can work through
the mechanics of the next few examples to see just how versatile slicing
with \texttt{ix} actually is.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}82}]:} \PY{n}{data}\PY{o}{.}\PY{n}{ix}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}82}]:} one       8
         two       9
         three    10
         four     11
         Name: Utah, dtype: int64
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}83}]:} \PY{n}{data}\PY{o}{.}\PY{n}{ix}\PY{p}{[}\PY{p}{:}\PY{l+s}{\PYZsq{}}\PY{l+s}{Utah}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{two}\PY{l+s}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}83}]:} Ohio        0
         Colorado    5
         Utah        9
         Name: two, dtype: int64
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}84}]:} \PY{n}{data}\PY{o}{.}\PY{n}{ix}\PY{p}{[}\PY{n}{data}\PY{o}{.}\PY{n}{three} \PY{o}{\PYZgt{}} \PY{l+m+mi}{5}\PY{p}{,} \PY{p}{:}\PY{l+m+mi}{3}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}84}]:}           one  two  three
         Colorado    0    5      6
         Utah        8    9     10
         New York   12   13     14
\end{Verbatim}
        
    \subsection{Arithmetic and data
alignment}\label{arithmetic-and-data-alignment}

    As we mentioned before, we can do arithmetic on \texttt{Series} and
\texttt{DataFrame} objects.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}85}]:} \PY{n}{s1} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mf}{7.3}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mf}{2.5}\PY{p}{,} \PY{l+m+mf}{3.4}\PY{p}{,} \PY{l+m+mf}{1.5}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{e}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{s2} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mf}{2.1}\PY{p}{,} \PY{l+m+mf}{3.6}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mf}{1.5}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mf}{3.1}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{e}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{f}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{g}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{k}{print} \PY{n}{s1}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+se}{\PYZbs{}n}\PY{l+s}{\PYZdq{}}
         \PY{k}{print} \PY{n}{s2}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
a    7.3
c   -2.5
d    3.4
e    1.5
dtype: float64 


a   -2.1
c    3.6
e   -1.5
f    4.0
g    3.1
dtype: float64
    \end{Verbatim}

    Importantly, arithmetic is only performed on elements sharing an index.
If either object has an index value that the other does not, the
arithmetic operation is undefined, so the resultant object contains an
\texttt{NaN} element.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}86}]:} \PY{n}{s1} \PY{o}{+} \PY{n}{s2}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}86}]:} a    5.2
         c    1.1
         d    NaN
         e    0.0
         f    NaN
         g    NaN
         dtype: float64
\end{Verbatim}
        
    The same holds for \texttt{DataFrame} arithmetic, except now it requires
that both the index and column of each \texttt{DataFrame} object is
well-defined.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}87}]:} \PY{n}{df1} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mf}{9.}\PY{p}{)}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}\PY{p}{,} \PY{n}{columns}\PY{o}{=}\PY{n+nb}{list}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{bcd}\PY{l+s}{\PYZsq{}}\PY{p}{)}\PY{p}{,}
                         \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Texas}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Colorado}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{df2} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mf}{12.}\PY{p}{)}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}\PY{p}{,} \PY{n}{columns}\PY{o}{=}\PY{n+nb}{list}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{bde}\PY{l+s}{\PYZsq{}}\PY{p}{)}\PY{p}{,}
                         \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Utah}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Texas}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Oregon}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{k}{print} \PY{n}{df1}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+se}{\PYZbs{}n}\PY{l+s}{\PYZdq{}}
         \PY{k}{print} \PY{n}{df2}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
b  c  d
Ohio      0  1  2
Texas     3  4  5
Colorado  6  7  8 


        b   d   e
Utah    0   1   2
Ohio    3   4   5
Texas   6   7   8
Oregon  9  10  11
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}88}]:} \PY{n}{df1} \PY{o}{+} \PY{n}{df2}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}88}]:}            b   c   d   e
         Colorado NaN NaN NaN NaN
         Ohio       3 NaN   6 NaN
         Oregon   NaN NaN NaN NaN
         Texas      9 NaN  12 NaN
         Utah     NaN NaN NaN NaN
\end{Verbatim}
        
    \subsubsection{Arithmetic methods with fill
values}\label{arithmetic-methods-with-fill-values}

    Often \texttt{NaN} values are undesirable, as they can cause errors when
doing arithmetic operations on the data.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}89}]:} \PY{n}{df1} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mf}{12.}\PY{p}{)}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)}\PY{p}{)}\PY{p}{,} \PY{n}{columns}\PY{o}{=}\PY{n+nb}{list}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{abcd}\PY{l+s}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
         \PY{n}{df2} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mf}{20.}\PY{p}{)}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}\PY{p}{)}\PY{p}{,} \PY{n}{columns}\PY{o}{=}\PY{n+nb}{list}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{abcde}\PY{l+s}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
         
         \PY{k}{print} \PY{n}{df1}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+se}{\PYZbs{}n}\PY{l+s}{\PYZdq{}}
         \PY{k}{print} \PY{n}{df2}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
a  b   c   d
0  0  1   2   3
1  4  5   6   7
2  8  9  10  11 


    a   b   c   d   e
0   0   1   2   3   4
1   5   6   7   8   9
2  10  11  12  13  14
3  15  16  17  18  19
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}90}]:} \PY{n}{df1} \PY{o}{+} \PY{n}{df2}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}90}]:}     a   b   c   d   e
         0   0   2   4   6 NaN
         1   9  11  13  15 NaN
         2  18  20  22  24 NaN
         3 NaN NaN NaN NaN NaN
\end{Verbatim}
        
    This can be avoided by using the built-in \texttt{DataFrame.add()}
method, which takes as parameters a \texttt{DataFrame} object \emph{and}
an optional \texttt{fill\_value} which deals with otherwise \texttt{NaN}
entries.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}91}]:} \PY{n}{df1}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{df2}\PY{p}{,} \PY{n}{fill\PYZus{}value}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}91}]:}     a   b   c   d   e
         0   0   2   4   6   4
         1   9  11  13  15   9
         2  18  20  22  24  14
         3  15  16  17  18  19
\end{Verbatim}
        
    In fact, most \texttt{DataFrame} organization methods take
\texttt{fill\_value} as a parameter to deal with undefined cases, such
as \texttt{reindex}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}92}]:} \PY{n}{df1}\PY{o}{.}\PY{n}{reindex}\PY{p}{(}\PY{n}{columns}\PY{o}{=}\PY{n}{df2}\PY{o}{.}\PY{n}{columns}\PY{p}{,} \PY{n}{fill\PYZus{}value}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}92}]:}    a  b   c   d  e
         0  0  1   2   3  0
         1  4  5   6   7  0
         2  8  9  10  11  0
\end{Verbatim}
        
    \subsection{Operations between DataFrame and
Series}\label{operations-between-dataframe-and-series}

    Broadcasting \texttt{NumPy} arrays is a very useful technique for
performing arithmetic operations concisely. And efficiently, actually.
This is because while normal \texttt{Python} arithmetic is
\emph{interpreted}, \texttt{NumPy} arithmetic is based on
\emph{compiled} \texttt{C} code, which is much more efficient in
general.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}93}]:} \PY{n}{arr} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mf}{12.}\PY{p}{)}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)}\PY{p}{)}
         \PY{n}{arr}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}93}]:} array([[  0.,   1.,   2.,   3.],
                [  4.,   5.,   6.,   7.],
                [  8.,   9.,  10.,  11.]])
\end{Verbatim}
        
    Normally we think of broadcasting a scalar element onto a
one-dimensional array vector. In fact, broadcasting is much more
powerful, because you can broadcast an \emph{array} over a bigger array.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}94}]:} \PY{n}{arr}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}94}]:} array([ 0.,  1.,  2.,  3.])
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}95}]:} \PY{n}{arr} \PY{o}{\PYZhy{}} \PY{n}{arr}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}95}]:} array([[ 0.,  0.,  0.,  0.],
                [ 4.,  4.,  4.,  4.],
                [ 8.,  8.,  8.,  8.]])
\end{Verbatim}
        
    \texttt{DataFrame} and \texttt{Series} objects work along similar lines.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}96}]:} \PY{n}{frame} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mf}{12.}\PY{p}{)}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}\PY{p}{,} \PY{n}{columns}\PY{o}{=}\PY{n+nb}{list}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{bde}\PY{l+s}{\PYZsq{}}\PY{p}{)}\PY{p}{,}
                           \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Utah}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Texas}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Oregon}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{series} \PY{o}{=} \PY{n}{frame}\PY{o}{.}\PY{n}{ix}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
         \PY{k}{print} \PY{n}{frame}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+se}{\PYZbs{}n}\PY{l+s}{\PYZdq{}}
         \PY{k}{print} \PY{n}{series}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
b   d   e
Utah    0   1   2
Ohio    3   4   5
Texas   6   7   8
Oregon  9  10  11 


b    0
d    1
e    2
Name: Utah, dtype: float64
    \end{Verbatim}

    You can broadcast the values in a \texttt{Series} over its parent
\texttt{DataFrame} as you would with \texttt{NumPy ndarrays}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}97}]:} \PY{n}{frame} \PY{o}{\PYZhy{}} \PY{n}{series}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}97}]:}         b  d  e
         Utah    0  0  0
         Ohio    3  3  3
         Texas   6  6  6
         Oregon  9  9  9
\end{Verbatim}
        
    Of course, if either a \texttt{Series} and \texttt{DataFrame} object has
index or column values the other does not, the undefined arithmetic
simply is sent to \texttt{NaN}. (We discussed ways to avoid this issue
in the previous sections).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}98}]:} \PY{n}{series2} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{e}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{f}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{frame} \PY{o}{+} \PY{n}{series2}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}98}]:}         b   d   e   f
         Utah    0 NaN   3 NaN
         Ohio    3 NaN   6 NaN
         Texas   6 NaN   9 NaN
         Oregon  9 NaN  12 NaN
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}99}]:} \PY{n}{series3} \PY{o}{=} \PY{n}{frame}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{]}
         
         \PY{k}{print} \PY{n}{frame}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+se}{\PYZbs{}n}\PY{l+s}{\PYZdq{}}
         \PY{k}{print} \PY{n}{series3}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
b   d   e
Utah    0   1   2
Ohio    3   4   5
Texas   6   7   8
Oregon  9  10  11 


Utah       1
Ohio       4
Texas      7
Oregon    10
Name: d, dtype: float64
    \end{Verbatim}

    Using the built-in \texttt{DataFrame} arithmetic operations such as
\texttt{add} or \texttt{sub} gives the option to specify the axis (0:
index, 1: columns) over which the arithmetic will take place (again, you
can use \texttt{fill\_value} to avoid potential \texttt{NaN} values).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}100}]:} \PY{n}{frame}\PY{o}{.}\PY{n}{sub}\PY{p}{(}\PY{n}{series3}\PY{p}{,} \PY{n}{axis}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}100}]:}         b  d  e
          Utah   -1  0  1
          Ohio   -1  0  1
          Texas  -1  0  1
          Oregon -1  0  1
\end{Verbatim}
        
    \subsection{Function application and
mapping}\label{function-application-and-mapping}

    One of the most important capabilities of \texttt{Series} and
\texttt{DataFrame} is the ability to apply function transformations to
the data. Every \texttt{ufunc} defined by \texttt{NumPy} can be applied
to a \texttt{DataFrame} (or \texttt{Series}) object.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}101}]:} \PY{n}{frame} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{randn}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,} \PY{n}{columns}\PY{o}{=}\PY{n+nb}{list}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{bde}\PY{l+s}{\PYZsq{}}\PY{p}{)}\PY{p}{,}
                            \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Utah}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Texas}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Oregon}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
          \PY{n}{frame}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}101}]:}                b         d         e
          Utah    0.450554  0.092673  1.248133
          Ohio    0.768101  1.248804  0.774191
          Texas  -0.319657 -0.624964  1.078814
          Oregon  0.544647  0.855588  1.343268
\end{Verbatim}
        
    For example, you can apply a nonnegativity transform by including a
built-in \texttt{NumPy} absolute value.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}102}]:} \PY{n}{np}\PY{o}{.}\PY{n}{abs}\PY{p}{(}\PY{n}{frame}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}102}]:}                b         d         e
          Utah    0.450554  0.092673  1.248133
          Ohio    0.768101  1.248804  0.774191
          Texas   0.319657  0.624964  1.078814
          Oregon  0.544647  0.855588  1.343268
\end{Verbatim}
        
    You can define and apply custom functions in two fashions. One is by
using lambdas to construct anonymous functions:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}103}]:} \PY{n}{frame}\PY{o}{.}\PY{n}{apply}\PY{p}{(}\PY{k}{lambda} \PY{n}{x}\PY{p}{:} \PY{n}{x}\PY{o}{.}\PY{n}{max}\PY{p}{(}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{n}{x}\PY{o}{.}\PY{n}{min}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}103}]:} b    1.087758
          d    1.873768
          e    0.569077
          dtype: float64
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}104}]:} \PY{n}{frame}\PY{o}{.}\PY{n}{apply}\PY{p}{(}\PY{k}{lambda} \PY{n}{x}\PY{p}{:} \PY{n}{x}\PY{o}{.}\PY{n}{max}\PY{p}{(}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{n}{x}\PY{o}{.}\PY{n}{min}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{n}{axis}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}104}]:} Utah      1.155460
          Ohio      0.480703
          Texas     1.703778
          Oregon    0.798621
          dtype: float64
\end{Verbatim}
        
    Alternatively, you can define your own unary function and simply apply
it using the same overall approach.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}105}]:} \PY{k}{def} \PY{n+nf}{f}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
              \PY{k}{return} \PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{n}{x}\PY{o}{.}\PY{n}{min}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{n}{x}\PY{o}{.}\PY{n}{max}\PY{p}{(}\PY{p}{)}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{min}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{max}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
          \PY{n}{frame}\PY{o}{.}\PY{n}{apply}\PY{p}{(}\PY{n}{f}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}105}]:}             b         d         e
          min -0.319657 -0.624964  0.774191
          max  0.768101  1.248804  1.343268
\end{Verbatim}
        
    For presentations and general readability, it is useful to format
decimal or date values into condensed forms, and \texttt{Pandas} lets
you achieve this by using the \texttt{applymap} method for
\texttt{DataFrame} and \texttt{Series} objects. The difference between
\texttt{apply} and \texttt{applymap} is rather subtle and often
functionally neglibible, but the idea is that \texttt{apply} works on a
particular subsets of rows or columns, whereas \texttt{applymap} is
element-wise.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}106}]:} \PY{n}{format} \PY{o}{=} \PY{k}{lambda} \PY{n}{x}\PY{p}{:} \PY{l+s}{\PYZsq{}}\PY{l+s+si}{\PYZpc{}.2f}\PY{l+s}{\PYZsq{}} \PY{o}{\PYZpc{}} \PY{n}{x}
          \PY{n}{frame}\PY{o}{.}\PY{n}{applymap}\PY{p}{(}\PY{n}{format}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}106}]:}             b      d     e
          Utah     0.45   0.09  1.25
          Ohio     0.77   1.25  0.77
          Texas   -0.32  -0.62  1.08
          Oregon   0.54   0.86  1.34
\end{Verbatim}
        
    Alternatively, you can use the built-in \texttt{Python} \texttt{map}
function.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}107}]:} \PY{n}{frame}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{e}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{o}{.}\PY{n}{map}\PY{p}{(}\PY{n}{format}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}107}]:} Utah      1.25
          Ohio      0.77
          Texas     1.08
          Oregon    1.34
          Name: e, dtype: object
\end{Verbatim}
        
    \paragraph{Exercise:}\label{exercise}

Determine which of \texttt{apply} or \texttt{map} is computationally
more efficient.

    \subsection{Sorting and ranking}\label{sorting-and-ranking}

    One fundamental problem in data analysis, let alone computer science in
general, is sorting data. \texttt{Pandas} provides a number of
techniques for sorting information in the index, columns, and the actual
data itself.

The first technique is \texttt{sort\_index}, which is a method for both
\texttt{Series} and \texttt{DataFrame} objects. For \texttt{Series}
objects, \texttt{sort\_index} works as follows:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}108}]:} \PY{n}{obj} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
          \PY{n}{obj}\PY{o}{.}\PY{n}{sort\PYZus{}index}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}108}]:} a    1
          b    2
          c    3
          d    0
          dtype: int64
\end{Verbatim}
        
    Since there is only one meaningful index to sort, the labels,
\texttt{sort\_index} is a very intuitive method. I want to point out
that \texttt{sort\_index} does not have side-effects; that is, calling
\texttt{sort\_index} on an object does not actually change the internals
of the object itself. Instead, a sorted copy of the original object is
produced.

The method \texttt{sort\_index} works similarly with \texttt{DataFrame}
objects, but now there are two potential axes along which to sort. The
default is the \texttt{index}, as we see below:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}109}]:} \PY{n}{frame} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{)}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)}\PY{p}{)}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{three}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{one}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                            \PY{n}{columns}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
          \PY{n}{frame}\PY{o}{.}\PY{n}{sort\PYZus{}index}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}109}]:}        d  a  b  c
          one    4  5  6  7
          three  0  1  2  3
\end{Verbatim}
        
    By specifying the axis as a parameter, one can choose the columns
instead. (Recall that in \texttt{Python} everything begins at 0, so the
second axis corresponds to axis number 1).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}110}]:} \PY{n}{frame}\PY{o}{.}\PY{n}{sort\PYZus{}index}\PY{p}{(}\PY{n}{axis}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}110}]:}        a  b  c  d
          three  1  2  3  0
          one    5  6  7  4
\end{Verbatim}
        
    The \texttt{sort\_index} method also allows you to flip the ordering by
specifying the \texttt{ascending} parameter.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}111}]:} \PY{n}{frame}\PY{o}{.}\PY{n}{sort\PYZus{}index}\PY{p}{(}\PY{n}{axis}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{ascending}\PY{o}{=}\PY{n+nb+bp}{False}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}111}]:}        d  c  b  a
          three  0  3  2  1
          one    4  7  6  5
\end{Verbatim}
        
    If you want to sort the elements themselves, as opposed to the index,
\texttt{Pandas} provides the \texttt{order} method for \texttt{Series}
objects.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}112}]:} \PY{n}{obj} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{7}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}
          \PY{n}{obj}\PY{o}{.}\PY{n}{order}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}112}]:} 2   -3
          3    2
          0    4
          1    7
          dtype: int64
\end{Verbatim}
        
    By default, \texttt{NaN} values are placed at the end upon sorting the
\texttt{Series}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}113}]:} \PY{n}{obj} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{nan}\PY{p}{,} \PY{l+m+mi}{7}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{nan}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}
          \PY{n}{obj}\PY{o}{.}\PY{n}{order}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}113}]:} 4    -3
          5     2
          0     4
          2     7
          1   NaN
          3   NaN
          dtype: float64
\end{Verbatim}
        
    For \texttt{DataFrame} objects you can specify the index or column you
wish to sort. Additionally, if your data set is properly constructed,
you can sort by two columns or indices, as the below example exhibits:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}114}]:} \PY{n}{frame} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{7}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
          
          \PY{n}{frame}\PY{o}{.}\PY{n}{sort\PYZus{}index}\PY{p}{(}\PY{n}{by}\PY{o}{=}\PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}114}]:}    a  b
          2  0 -3
          3  1  2
          0  0  4
          1  1  7
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}115}]:} \PY{n}{frame}\PY{o}{.}\PY{n}{sort\PYZus{}index}\PY{p}{(}\PY{n}{by}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}115}]:}    a  b
          2  0 -3
          0  0  4
          3  1  2
          1  1  7
\end{Verbatim}
        
    \subsection{Axis indexes with duplicate
values}\label{axis-indexes-with-duplicate-values}

    It is possible for a \texttt{Series} or \texttt{DataFrame} object not to
have a unique index. For example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}116}]:} \PY{n}{obj} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
          \PY{n}{obj}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}116}]:} a    0
          a    1
          b    2
          b    3
          c    4
          dtype: int64
\end{Verbatim}
        
    \texttt{Pandas} has a field for the index of any object to indicate
whether or ot the index is unique (no duplicate indices).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}117}]:} \PY{n}{obj}\PY{o}{.}\PY{n}{index}\PY{o}{.}\PY{n}{is\PYZus{}unique}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}117}]:} False
\end{Verbatim}
        
    If an index is not unique, then slicing the object for a repeated index
returns a sub-object. For example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}118}]:} \PY{n}{obj}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}118}]:} a    0
          a    1
          dtype: int64
\end{Verbatim}
        
    For unique index items, the default return-type is a scalar:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}119}]:} \PY{n}{obj}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}119}]:} 4
\end{Verbatim}
        
    The same goes for \texttt{DataFrame} objects, although they are more
complicated.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}120}]:} \PY{n}{df} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{randn}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
          \PY{n}{df}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}120}]:}           0         1         2
          a -0.267175  1.793095 -0.652929
          a -1.886837  1.059626  0.644448
          b -0.007799 -0.449204  2.448963
          b  0.667226  0.802926  0.575721
\end{Verbatim}
        
    Remember that you have to slice the index using \texttt{ix}, and you
will observe the same behavior.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}121}]:} \PY{n}{df}\PY{o}{.}\PY{n}{ix}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}121}]:}           0         1         2
          b -0.007799 -0.449204  2.448963
          b  0.667226  0.802926  0.575721
\end{Verbatim}
        
    \section{Summarizing and computing descriptive
statistics}\label{summarizing-and-computing-descriptive-statistics}

    Oftentimes, you need a quick way to come up with basic summary
statistics of data sets. The solution that \texttt{Pandas} provides is
incredibly robust, especially with regard to \texttt{NaN} entries.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}122}]:} \PY{n}{df} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mf}{1.4}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{nan}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mf}{7.1}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mf}{4.5}\PY{p}{]}\PY{p}{,}
                          \PY{p}{[}\PY{n}{np}\PY{o}{.}\PY{n}{nan}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{nan}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mf}{0.75}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mf}{1.3}\PY{p}{]}\PY{p}{]}\PY{p}{,}
                         \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                         \PY{n}{columns}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{one}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{two}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
          \PY{n}{df}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}122}]:}     one  two
          a  1.40  NaN
          b  7.10 -4.5
          c   NaN  NaN
          d  0.75 -1.3
\end{Verbatim}
        
    By default, the \texttt{sum} method will skip \texttt{NaN} entries for
each column in a \texttt{DataFrame}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}123}]:} \PY{n}{df}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}123}]:} one    9.25
          two   -5.80
          dtype: float64
\end{Verbatim}
        
    For the \texttt{DataFrame} object, you can also apply along either the
index axis or the column axis. Again, \texttt{sum} will skip over
\texttt{NaN} elements when arriving at a value.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}124}]:} \PY{n}{df}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{n}{axis}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}124}]:} a    1.40
          b    2.60
          c     NaN
          d   -0.55
          dtype: float64
\end{Verbatim}
        
    If you don't want this behavior, you can always tell the statistics
function you are applying not to skip the \texttt{NaN} entries. Here is
an example using \texttt{mean}:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}125}]:} \PY{n}{df}\PY{o}{.}\PY{n}{mean}\PY{p}{(}\PY{n}{axis}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{skipna}\PY{o}{=}\PY{n+nb+bp}{False}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}125}]:} a      NaN
          b    1.300
          c      NaN
          d   -0.275
          dtype: float64
\end{Verbatim}
        
    Another useful statistic is \texttt{idxmax}, which returns the index of
the maximum value of a column in a \texttt{DataFrame}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}126}]:} \PY{n}{df}\PY{o}{.}\PY{n}{idxmax}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}126}]:} one    b
          two    d
          dtype: object
\end{Verbatim}
        
    One incredibly useful method is \texttt{cumsum}, which has a number of
important applications in the analysis of probability distributions and
random walks.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}127}]:} \PY{n}{df}\PY{o}{.}\PY{n}{cumsum}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}127}]:}     one  two
          a  1.40  NaN
          b  8.50 -4.5
          c   NaN  NaN
          d  9.25 -5.8
\end{Verbatim}
        
    You can also get a quick overview of all of the summary statistics of a
\texttt{DataFrame} simply by calling the \texttt{describe} method.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}128}]:} \PY{n}{df}\PY{o}{.}\PY{n}{describe}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}128}]:}             one       two
          count  3.000000  2.000000
          mean   3.083333 -2.900000
          std    3.493685  2.262742
          min    0.750000 -4.500000
          25\%    1.075000 -3.700000
          50\%    1.400000 -2.900000
          75\%    4.250000 -2.100000
          max    7.100000 -1.300000
\end{Verbatim}
        
    \paragraph{Descriptive and Summary
Statistics}\label{descriptive-and-summary-statistics}

\begin{longtable}[c]{@{}ll@{}}
\toprule\addlinespace
Method & Description
\\\addlinespace
\midrule\endhead
\texttt{count} & Number of non-\texttt{NaN} values
\\\addlinespace
\texttt{describe} & Compute set of summary statistics for Series or each
\texttt{DataFrame} column
\\\addlinespace
\texttt{min}, \texttt{max} & Compute minimum and maximum values
\\\addlinespace
\texttt{argmin}, \texttt{argmax} & Compute index locations for minimum
and maximum values
\\\addlinespace
\texttt{idmin}, \texttt{idmax} & Compute index values for minimum and
maximum values
\\\addlinespace
\texttt{quantile} & Compute sample quantile ranging from 0 to 1
\\\addlinespace
\texttt{sum} & Sum of values
\\\addlinespace
\texttt{mean} & Mean of values
\\\addlinespace
\texttt{median} & Arithmetic median of values
\\\addlinespace
\texttt{mad} & Mean absolute deviation from mean value
\\\addlinespace
\texttt{var} & Sample variance of values
\\\addlinespace
\texttt{std} & Sample standard deviation of values
\\\addlinespace
\texttt{skew} & Sample skewness (3rd moment) of values
\\\addlinespace
\texttt{kurt} & Sample kurtosis (4th moment) of values
\\\addlinespace
\texttt{cumsum} & Cumulative sum of values
\\\addlinespace
\texttt{cummin}, \texttt{cummax} & Cumulative min and max of values
\\\addlinespace
\texttt{cumprod} & cumulative product of values
\\\addlinespace
\texttt{diff} & Compute 1st arithmetic difference (useful for time
series
\\\addlinespace
\texttt{pct\_change} & Compute percent changes
\\\addlinespace
\bottomrule
\end{longtable}

    \texttt{Series} objects also have a \texttt{describe} method. The
\texttt{describe} method outputs statistics based on the \texttt{dtype}
of the underlying object. In the above example, \texttt{df} had a
\texttt{dtype} of \texttt{float64}, so \texttt{describe} produced
information pertinent to floating-point numerics. In the below example,
the \texttt{Series} object has a \texttt{dtype} of \texttt{object},
which results in different summary statistics.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}129}]:} \PY{n}{obj} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{]} \PY{o}{*} \PY{l+m+mi}{4}\PY{p}{)}
          \PY{n}{obj}\PY{o}{.}\PY{n}{describe}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}129}]:} count     16
          unique     3
          top        a
          freq       8
          dtype: object
\end{Verbatim}
        
    \subsection{Correlation and
covariance}\label{correlation-and-covariance}

    One common problem in data analysis, especially in the analysis of time
series data like historical prices for financial securities, is
correlation and covariance analysis. To this end \texttt{Pandas} has a
number of features to make the analysis simple.

    Here is one example, using a built-in data aggregator using
\href{http://finance.yahoo.com/}{Yahoo! Finance} in the \texttt{Pandas}
API. Returns on a stock are defined as the percent change in the stock's
closing value from day-to-day.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}130}]:} \PY{k+kn}{import} \PY{n+nn}{pandas.io.data} \PY{k+kn}{as} \PY{n+nn}{web}
          
          \PY{n}{all\PYZus{}data} \PY{o}{=} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}
          \PY{k}{for} \PY{n}{ticker} \PY{o+ow}{in} \PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{AAPL}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{IBM}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{MSFT}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{CSCO}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{:}
              \PY{n}{all\PYZus{}data}\PY{p}{[}\PY{n}{ticker}\PY{p}{]} \PY{o}{=} \PY{n}{web}\PY{o}{.}\PY{n}{get\PYZus{}data\PYZus{}yahoo}\PY{p}{(}\PY{n}{ticker}\PY{p}{)}
          
          \PY{n}{price} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{n}{tic}\PY{p}{:} \PY{n}{data}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Adj Close}\PY{l+s}{\PYZsq{}}\PY{p}{]}
                             \PY{k}{for} \PY{n}{tic}\PY{p}{,} \PY{n}{data} \PY{o+ow}{in} \PY{n}{all\PYZus{}data}\PY{o}{.}\PY{n}{iteritems}\PY{p}{(}\PY{p}{)}\PY{p}{\PYZcb{}}\PY{p}{)}
          \PY{n}{volume} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{n}{tic}\PY{p}{:} \PY{n}{data}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Volume}\PY{l+s}{\PYZsq{}}\PY{p}{]}
                              \PY{k}{for} \PY{n}{tic}\PY{p}{,} \PY{n}{data} \PY{o+ow}{in} \PY{n}{all\PYZus{}data}\PY{o}{.}\PY{n}{iteritems}\PY{p}{(}\PY{p}{)}\PY{p}{\PYZcb{}}\PY{p}{)}
          
          \PY{n}{returns} \PY{o}{=} \PY{n}{price}\PY{o}{.}\PY{n}{pct\PYZus{}change}\PY{p}{(}\PY{p}{)}
          \PY{n}{returns}\PY{o}{.}\PY{n}{tail}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}130}]:}                 AAPL      CSCO       IBM      MSFT
          Date                                              
          2015-03-25 -0.026127 -0.019431 -0.023313 -0.033566
          2015-03-26  0.006970 -0.013578  0.008731 -0.006030
          2015-03-27 -0.007968  0.001488 -0.001183 -0.005824
          2015-03-30  0.025314  0.019316  0.014152 -0.000244
          2015-03-31 -0.015352  0.003280 -0.013340 -0.007324
\end{Verbatim}
        
    When given a \texttt{Series} object, the \texttt{corr} method computes
the scalar correlation between the \texttt{Series} and another
\texttt{Series}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}131}]:} \PY{n}{returns}\PY{o}{.}\PY{n}{MSFT}\PY{o}{.}\PY{n}{corr}\PY{p}{(}\PY{n}{returns}\PY{o}{.}\PY{n}{IBM}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}131}]:} 0.50144660652462925
\end{Verbatim}
        
    By contrast, \texttt{corr} and \texttt{cov} returns a correlation and
covariance matrix \texttt{DataFrame} with filled correlation and
covariance values, respectively.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}132}]:} \PY{n}{returns}\PY{o}{.}\PY{n}{MSFT}\PY{o}{.}\PY{n}{cov}\PY{p}{(}\PY{n}{returns}\PY{o}{.}\PY{n}{IBM}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}132}]:} 8.3470993744258389e-05
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}133}]:} \PY{n}{returns}\PY{o}{.}\PY{n}{corr}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}133}]:}           AAPL      CSCO       IBM      MSFT
          AAPL  1.000000  0.335746  0.371383  0.347494
          CSCO  0.335746  1.000000  0.448426  0.464868
          IBM   0.371383  0.448426  1.000000  0.501447
          MSFT  0.347494  0.464868  0.501447  1.000000
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}134}]:} \PY{n}{returns}\PY{o}{.}\PY{n}{cov}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}134}]:}           AAPL      CSCO       IBM      MSFT
          AAPL  0.000283  0.000098  0.000073  0.000083
          CSCO  0.000098  0.000301  0.000091  0.000114
          IBM   0.000073  0.000091  0.000138  0.000083
          MSFT  0.000083  0.000114  0.000083  0.000200
\end{Verbatim}
        
    The \texttt{corrwith} method computes pairwise correlations and stores
the resultant in a \texttt{Series}. Note that the correlation between
IBM and IBM is 1.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}135}]:} \PY{n}{returns}\PY{o}{.}\PY{n}{corrwith}\PY{p}{(}\PY{n}{returns}\PY{o}{.}\PY{n}{IBM}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}135}]:} AAPL    0.371383
          CSCO    0.448426
          IBM     1.000000
          MSFT    0.501447
          dtype: float64
\end{Verbatim}
        
    Passing a \texttt{DataFrame} instead computes correlation with
like-columns.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}136}]:} \PY{n}{returns}\PY{o}{.}\PY{n}{corrwith}\PY{p}{(}\PY{n}{volume}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}136}]:} AAPL   -0.097904
          CSCO   -0.235580
          IBM    -0.184944
          MSFT   -0.120080
          dtype: float64
\end{Verbatim}
        
    \subsection{Unique values, value counts, and
membership}\label{unique-values-value-counts-and-membership}

    Given data with repeats, you can eliminate the excess by using the
\texttt{unique} method.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}137}]:} \PY{n}{obj} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
          \PY{n}{uniques} \PY{o}{=} \PY{n}{obj}\PY{o}{.}\PY{n}{unique}\PY{p}{(}\PY{p}{)}
          \PY{n}{uniques}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}137}]:} array(['c', 'a', 'd', 'b'], dtype=object)
\end{Verbatim}
        
    The \texttt{value\_counts} returns a \texttt{Series} with an index made
up of the unique entries in the original \texttt{Series}, and the new
entries give the total appearances of each value.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}138}]:} \PY{n}{obj}\PY{o}{.}\PY{n}{value\PYZus{}counts}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}138}]:} c    3
          a    3
          b    2
          d    1
          dtype: int64
\end{Verbatim}
        
    You can perform set-membership operations to, for example, construct
masks which you can then apply to your original data.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}139}]:} \PY{n}{mask} \PY{o}{=} \PY{n}{obj}\PY{o}{.}\PY{n}{isin}\PY{p}{(}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)} \PY{c}{\PYZsh{} This forms a Series object of Boolean values}
          \PY{n}{obj}\PY{p}{[}\PY{n}{mask}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}139}]:} 0    c
          5    b
          6    b
          7    c
          8    c
          dtype: object
\end{Verbatim}
        
    For \texttt{DataFrame} objects, you can apply the \texttt{value\_counts}
method to each subseries, producing a new \texttt{DataFrame} of
frequency statistics.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}140}]:} \PY{n}{data} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s}{\PYZsq{}}\PY{l+s}{Qu1}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{]}\PY{p}{,}
                            \PY{l+s}{\PYZsq{}}\PY{l+s}{Qu2}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,}
                            \PY{l+s}{\PYZsq{}}\PY{l+s}{Qu3}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
          \PY{n}{data}\PY{o}{.}\PY{n}{apply}\PY{p}{(}\PY{n}{pd}\PY{o}{.}\PY{n}{value\PYZus{}counts}\PY{p}{)}\PY{o}{.}\PY{n}{fillna}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}140}]:}    Qu1  Qu2  Qu3
          1    1    1    1
          2    0    2    1
          3    2    2    0
          4    2    0    2
          5    0    0    1
\end{Verbatim}
        
    \section{Handling missing data}\label{handling-missing-data}

    One of the primary problems with data analysis is the prevalence of
missing data. In many cases, arithmetic operations, summary statistics,
and other functions require that your data be intact in order to provide
meaningful results. \texttt{Pandas} gives a number of functions to
address the problem of missing data, allowing you to filter it out
easily.

Consider this \texttt{Series} of \texttt{string} values.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}141}]:} \PY{n}{string\PYZus{}data} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{aardvark}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{artichoke}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{nan}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{avocado}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
          \PY{n}{string\PYZus{}data}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}141}]:} 0     aardvark
          1    artichoke
          2          NaN
          3      avocado
          dtype: object
\end{Verbatim}
        
    The \texttt{isnull} method identifies every \texttt{NaN} entry.
Alternatively,\texttt{notnull} will identify every non-\texttt{NaN}
entry.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}142}]:} \PY{n}{string\PYZus{}data}\PY{o}{.}\PY{n}{isnull}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}142}]:} 0    False
          1    False
          2     True
          3    False
          dtype: bool
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}143}]:} \PY{n}{string\PYZus{}data}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]} \PY{o}{=} \PY{n+nb+bp}{None}
          \PY{n}{string\PYZus{}data}\PY{o}{.}\PY{n}{notnull}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}143}]:} 0    False
          1     True
          2    False
          3     True
          dtype: bool
\end{Verbatim}
        
    \subsection{Filtering out missing
data}\label{filtering-out-missing-data}

    A simple way to remove missing entries from a \texttt{Series} object is
to use \texttt{dropna}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}144}]:} \PY{k+kn}{from} \PY{n+nn}{numpy} \PY{k+kn}{import} \PY{n}{nan} \PY{k}{as} \PY{n}{NA}
          \PY{n}{data} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{NA}\PY{p}{,} \PY{l+m+mf}{3.5}\PY{p}{,} \PY{n}{NA}\PY{p}{,} \PY{l+m+mi}{7}\PY{p}{]}\PY{p}{)}
          \PY{n}{data}\PY{o}{.}\PY{n}{dropna}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}144}]:} 0    1.0
          2    3.5
          4    7.0
          dtype: float64
\end{Verbatim}
        
    Alternatively, you can use \texttt{Boolean} \texttt{Series} and
\texttt{notnull} to mask the original data.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}145}]:} \PY{n}{data}\PY{p}{[}\PY{n}{data}\PY{o}{.}\PY{n}{notnull}\PY{p}{(}\PY{p}{)}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}145}]:} 0    1.0
          2    3.5
          4    7.0
          dtype: float64
\end{Verbatim}
        
    \texttt{DataFrame} objects are trickier. For example, how should
\texttt{Pandas} handle a mostly-complete row? The correct answer is
ambiguous. By default, \texttt{dropna} will eliminate \emph{any} row
with a \texttt{NaN} (we redefined \texttt{NaN} to \texttt{NA} here)
value.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}146}]:} \PY{n}{data} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mf}{1.}\PY{p}{,} \PY{l+m+mf}{6.5}\PY{p}{,} \PY{l+m+mf}{3.}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mf}{1.}\PY{p}{,} \PY{n}{NA}\PY{p}{,} \PY{n}{NA}\PY{p}{]}\PY{p}{,}
                            \PY{p}{[}\PY{n}{NA}\PY{p}{,} \PY{n}{NA}\PY{p}{,} \PY{n}{NA}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{n}{NA}\PY{p}{,} \PY{l+m+mf}{6.5}\PY{p}{,} \PY{l+m+mf}{3.}\PY{p}{]}\PY{p}{]}\PY{p}{)}
          \PY{n}{cleaned} \PY{o}{=} \PY{n}{data}\PY{o}{.}\PY{n}{dropna}\PY{p}{(}\PY{p}{)}
          \PY{n}{data}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}146}]:}     0    1   2
          0   1  6.5   3
          1   1  NaN NaN
          2 NaN  NaN NaN
          3 NaN  6.5   3
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}147}]:} \PY{n}{cleaned}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}147}]:}    0    1  2
          0  1  6.5  3
\end{Verbatim}
        
    Alternatively, you can require that a row be eliminated only if it is
\emph{completely} empty.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}148}]:} \PY{n}{data}\PY{o}{.}\PY{n}{dropna}\PY{p}{(}\PY{n}{how}\PY{o}{=}\PY{l+s}{\PYZsq{}}\PY{l+s}{all}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}148}]:}     0    1   2
          0   1  6.5   3
          1   1  NaN NaN
          3 NaN  6.5   3
\end{Verbatim}
        
    You can also specify columns for deletion. Again, you can change the
deletion requirements as needed.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}149}]:} \PY{n}{data}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{]} \PY{o}{=} \PY{n}{NA} \PY{c}{\PYZsh{} fill a column entirely with NA}
          \PY{n}{data}\PY{o}{.}\PY{n}{dropna}\PY{p}{(}\PY{n}{axis}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{how}\PY{o}{=}\PY{l+s}{\PYZsq{}}\PY{l+s}{all}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}149}]:}     0    1   2
          0   1  6.5   3
          1   1  NaN NaN
          2 NaN  NaN NaN
          3 NaN  6.5   3
\end{Verbatim}
        
    The \texttt{dropna} method is very robust. You can also specify a
minimum threshold of data in a particular row as a criterion for
deletion. In the next example, we threshold at 2 entries per row,
allowing rows with one \texttt{NaN} value to stay while deleting any
more patchy rows.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}150}]:} \PY{n}{df} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{randn}\PY{p}{(}\PY{l+m+mi}{7}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}
          \PY{n}{df}\PY{o}{.}\PY{n}{ix}\PY{p}{[}\PY{p}{:}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{n}{NA}\PY{p}{;} \PY{n}{df}\PY{o}{.}\PY{n}{ix}\PY{p}{[}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{]} \PY{o}{=} \PY{n}{NA}
          \PY{n}{df}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}150}]:}           0         1         2
          0  1.381918       NaN       NaN
          1 -0.206282       NaN       NaN
          2  1.811659       NaN       NaN
          3 -1.313554       NaN -0.615939
          4  0.174072       NaN -0.035408
          5 -1.194063  1.037339 -0.364987
          6 -0.215726  0.763525  0.671308
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}151}]:} \PY{n}{df}\PY{o}{.}\PY{n}{dropna}\PY{p}{(}\PY{n}{thresh}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}151}]:}           0         1         2
          3 -1.313554       NaN -0.615939
          4  0.174072       NaN -0.035408
          5 -1.194063  1.037339 -0.364987
          6 -0.215726  0.763525  0.671308
\end{Verbatim}
        
    \subsection{Filling in missing data}\label{filling-in-missing-data}

    Instead of eliminating missing data outright, \texttt{Pandas} lets you
fill in the missing values. The simple approach, using \texttt{fillna},
is to pass a value that will then replace every \texttt{NaN} entry.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}152}]:} \PY{n}{df}\PY{o}{.}\PY{n}{fillna}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}152}]:}           0         1         2
          0  1.381918  0.000000  0.000000
          1 -0.206282  0.000000  0.000000
          2  1.811659  0.000000  0.000000
          3 -1.313554  0.000000 -0.615939
          4  0.174072  0.000000 -0.035408
          5 -1.194063  1.037339 -0.364987
          6 -0.215726  0.763525  0.671308
\end{Verbatim}
        
    Alternatively, you can specify different fill values in different
columns by giving a \texttt{dict} with keys of column names.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}153}]:} \PY{n}{df}\PY{o}{.}\PY{n}{fillna}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+m+mi}{1}\PY{p}{:} \PY{l+m+mf}{0.5}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{:} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{\PYZcb{}}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}153}]:}           0         1         2
          0  1.381918  0.500000 -1.000000
          1 -0.206282  0.500000 -1.000000
          2  1.811659  0.500000 -1.000000
          3 -1.313554  0.500000 -0.615939
          4  0.174072  0.500000 -0.035408
          5 -1.194063  1.037339 -0.364987
          6 -0.215726  0.763525  0.671308
\end{Verbatim}
        
    Using the \texttt{inplace} argument, you can overwrite the original
\texttt{DataFrame} object.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}154}]:} \PY{c}{\PYZsh{} always returns a reference to the filled object}
          \PY{n}{\PYZus{}} \PY{o}{=} \PY{n}{df}\PY{o}{.}\PY{n}{fillna}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{inplace}\PY{o}{=}\PY{n+nb+bp}{True}\PY{p}{)}
          \PY{n}{df}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}154}]:}           0         1         2
          0  1.381918  0.000000  0.000000
          1 -0.206282  0.000000  0.000000
          2  1.811659  0.000000  0.000000
          3 -1.313554  0.000000 -0.615939
          4  0.174072  0.000000 -0.035408
          5 -1.194063  1.037339 -0.364987
          6 -0.215726  0.763525  0.671308
\end{Verbatim}
        
    The other main filling technique is to fill by procedure. \texttt{ffill}
will copy the previous value in a column into the \texttt{NaN} entry.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}155}]:} \PY{n}{df} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{randn}\PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}
          \PY{n}{df}\PY{o}{.}\PY{n}{ix}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{:}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{n}{NA}\PY{p}{;} \PY{n}{df}\PY{o}{.}\PY{n}{ix}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{:}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{]} \PY{o}{=} \PY{n}{NA}
          \PY{k}{print} \PY{n}{df}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+se}{\PYZbs{}n}\PY{l+s}{\PYZdq{}}
          \PY{k}{print} \PY{n}{df}\PY{o}{.}\PY{n}{fillna}\PY{p}{(}\PY{n}{method}\PY{o}{=}\PY{l+s}{\PYZsq{}}\PY{l+s}{ffill}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
0         1         2
0 -1.810961 -0.246414 -0.205597
1  0.998181  0.625001  0.410271
2  0.063753       NaN  0.289051
3 -2.202882 -0.068072  0.033761
4  1.840764       NaN       NaN
5 -0.024116  1.462648       NaN 


          0         1         2
0 -1.810961 -0.246414 -0.205597
1  0.998181  0.625001  0.410271
2  0.063753  0.625001  0.289051
3 -2.202882 -0.068072  0.033761
4  1.840764 -0.068072  0.033761
5 -0.024116  1.462648  0.033761
    \end{Verbatim}

    In cases where you don't want this to extend indefinitely, you can limit
the fill method to a certain number of \texttt{NaN} entries after the
last available one.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}156}]:} \PY{n}{df}\PY{o}{.}\PY{n}{fillna}\PY{p}{(}\PY{n}{method}\PY{o}{=}\PY{l+s}{\PYZsq{}}\PY{l+s}{ffill}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{n}{limit}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}156}]:}           0         1         2
          0 -1.810961 -0.246414 -0.205597
          1  0.998181  0.625001  0.410271
          2  0.063753  0.625001  0.289051
          3 -2.202882 -0.068072  0.033761
          4  1.840764 -0.068072  0.033761
          5 -0.024116  1.462648       NaN
\end{Verbatim}
        
    \section{Hierarchical indexing}\label{hierarchical-indexing}

    From ``Python for Data Analysis'':

\begin{quote}
\emph{Hierarchical indexing} is an important feature of pandas enabling
you to have multiple (two or more) index \emph{levels} on an axis.
Somewhat abstractly, it provides a way for you to work with higher
dimensional data in a lower dimensional form. Let's start with a simple
example; create a \texttt{Series} with a list of lists or arrays as the
index:
\end{quote}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}157}]:} \PY{n}{data} \PY{o}{=} \PY{n}{Series}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{randn}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{,}
                        \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                               \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{]}\PY{p}{)}
          \PY{n}{data}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}157}]:} a  1    0.221755
             2   -0.838210
             3    1.396553
          b  1   -1.553775
             2   -0.007680
             3    1.335753
          c  1   -1.296638
             2    1.067990
          d  2   -0.743429
             3    0.500286
          dtype: float64
\end{Verbatim}
        
    Notice how the index \texttt{a} corresponds to the sub-indices
\texttt{1} and \texttt{2}, and their corresponding data. The
\texttt{index} object is thus not a simple list but a series of lists
corresponding to the inner sub-indices.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}158}]:} \PY{n}{data}\PY{o}{.}\PY{n}{index}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}158}]:} MultiIndex(levels=[[u'a', u'b', u'c', u'd'], [1, 2, 3]],
                     labels=[[0, 0, 0, 1, 1, 1, 2, 2, 3, 3], [0, 1, 2, 0, 1, 2, 0, 1, 1, 2]])
\end{Verbatim}
        
    Accessing an outer label will give you the sub-\texttt{Series} that it
corresponds to.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}159}]:} \PY{k}{print} \PY{n}{data}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+se}{\PYZbs{}n}\PY{l+s}{\PYZdq{}}
          \PY{k}{print} \PY{n}{data}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{:}\PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
1   -1.553775
2   -0.007680
3    1.335753
dtype: float64 


b  1   -1.553775
   2   -0.007680
   3    1.335753
c  1   -1.296638
   2    1.067990
dtype: float64
    \end{Verbatim}

    You can access sub-indices, which returns the \texttt{Series} of all
upper indices and their corresponding values.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}160}]:} \PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}160}]:} a   -0.838210
          b   -0.007680
          c    1.067990
          d   -0.743429
          dtype: float64
\end{Verbatim}
        
    You can use \texttt{unstack} to take the multi-index and place it into a
\texttt{DataFrame} object.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}161}]:} \PY{n}{data}\PY{o}{.}\PY{n}{unstack}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}161}]:}           1         2         3
          a  0.221755 -0.838210  1.396553
          b -1.553775 -0.007680  1.335753
          c -1.296638  1.067990       NaN
          d       NaN -0.743429  0.500286
\end{Verbatim}
        
    The inverse of \texttt{unstack} is \texttt{stack}. Observe:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}162}]:} \PY{n}{data}\PY{o}{.}\PY{n}{unstack}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{stack}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}162}]:} a  1    0.221755
             2   -0.838210
             3    1.396553
          b  1   -1.553775
             2   -0.007680
             3    1.335753
          c  1   -1.296638
             2    1.067990
          d  2   -0.743429
             3    0.500286
          dtype: float64
\end{Verbatim}
        
    Multi-indexing has a similar logic with \texttt{DataFrame} objects, but
it becomes more complicated as both the index and the columns can be
given a hierarchy:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}163}]:} \PY{n}{frame} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mi}{12}\PY{p}{)}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}\PY{p}{,}
                            \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{]}\PY{p}{]}\PY{p}{,}
                            \PY{n}{columns}\PY{o}{=}\PY{p}{[}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Colorado}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                                     \PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Green}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Red}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Green}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{]}\PY{p}{)}
          \PY{n}{frame}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}163}]:}      Ohio     Colorado
              Green Red    Green
          a 1     0   1        2
            2     3   4        5
          b 1     6   7        8
            2     9  10       11
\end{Verbatim}
        
    For clarity, let's rename the labels so we know what level we are
looking at.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}164}]:} \PY{n}{frame}\PY{o}{.}\PY{n}{index}\PY{o}{.}\PY{n}{names} \PY{o}{=} \PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{key1}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{key2}\PY{l+s}{\PYZsq{}}\PY{p}{]}
          \PY{n}{frame}\PY{o}{.}\PY{n}{columns}\PY{o}{.}\PY{n}{names} \PY{o}{=} \PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{state}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{color}\PY{l+s}{\PYZsq{}}\PY{p}{]}
          \PY{n}{frame}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}164}]:} state      Ohio     Colorado
          color     Green Red    Green
          key1 key2                   
          a    1        0   1        2
               2        3   4        5
          b    1        6   7        8
               2        9  10       11
\end{Verbatim}
        
    Now by specifying any column, whether on the top level or any sublevel,
you can get the \texttt{DataFrame} of values corresponding to the name.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}165}]:} \PY{n}{frame}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}165}]:} color      Green  Red
          key1 key2            
          a    1         0    1
               2         3    4
          b    1         6    7
               2         9   10
\end{Verbatim}
        
    \texttt{MultiIndex} objects are independent in \texttt{Pandas}, meaning
that you can create them without a corresponding \texttt{DataFrame} and
reuse them as needed.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}166}]:} \PY{k+kn}{from} \PY{n+nn}{pandas} \PY{k+kn}{import} \PY{n}{MultiIndex}
          \PY{n}{MultiIndex}\PY{o}{.}\PY{n}{from\PYZus{}arrays}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Ohio}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Colorado}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{Green}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Red}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{Green}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{]}\PY{p}{,}
                                 \PY{n}{names}\PY{o}{=}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{state}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{color}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}166}]:} MultiIndex(levels=[[u'Colorado', u'Ohio'], [u'Green', u'Red']],
                     labels=[[1, 1, 0], [0, 1, 0]],
                     names=[u'state', u'color'])
\end{Verbatim}
        
    \subsection{Reordering and sorting
levels}\label{reordering-and-sorting-levels}

    You can always swap indices on the same level. For example, if you want
\texttt{key2} and \texttt{key1} to switch, you can write

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}167}]:} \PY{n}{frame}\PY{o}{.}\PY{n}{swaplevel}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{key1}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{key2}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}167}]:} state      Ohio     Colorado
          color     Green Red    Green
          key2 key1                   
          1    a        0   1        2
          2    a        3   4        5
          1    b        6   7        8
          2    b        9  10       11
\end{Verbatim}
        
    Additionally, you can sort a particular index (in general, you can't
sort them all). Specify the index by its order (first is 0, second is
2), and you will see the sort take place:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}168}]:} \PY{n}{frame}\PY{o}{.}\PY{n}{sortlevel}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}168}]:} state      Ohio     Colorado
          color     Green Red    Green
          key1 key2                   
          a    1        0   1        2
          b    1        6   7        8
          a    2        3   4        5
          b    2        9  10       11
\end{Verbatim}
        
    As with the object-oriented paradigm, you can combine these actions into
one statement. For example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}169}]:} \PY{n}{frame}\PY{o}{.}\PY{n}{swaplevel}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{o}{.}\PY{n}{sortlevel}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}169}]:} state      Ohio     Colorado
          color     Green Red    Green
          key2 key1                   
          1    a        0   1        2
               b        6   7        8
          2    a        3   4        5
               b        9  10       11
\end{Verbatim}
        
    \subsection{Summary statistics by
level}\label{summary-statistics-by-level}

    With hierarchical indexing, you can specify the level and axis with
which to compute summary statistics. If one wants to compute the sum of
all values in the \texttt{key2} index, you get the relevant
sub-\texttt{DataFrame}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}170}]:} \PY{n}{frame}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{n}{level}\PY{o}{=}\PY{l+s}{\PYZsq{}}\PY{l+s}{key2}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}170}]:} state  Ohio     Colorado
          color Green Red    Green
          key2                    
          1         6   8       10
          2        12  14       16
\end{Verbatim}
        
    This of course gets extended to the columns as well, which you have
grown accustomed to with \texttt{DataFrame} methods.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}171}]:} \PY{n}{frame}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{n}{level}\PY{o}{=}\PY{l+s}{\PYZsq{}}\PY{l+s}{color}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{n}{axis}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}171}]:} color      Green  Red
          key1 key2            
          a    1         2    1
               2         8    4
          b    1        14    7
               2        20   10
\end{Verbatim}
        
    \subsection{Using a DataFrame's
columns}\label{using-a-dataframes-columns}

    In the examples above we showed how to \texttt{stack} and
\texttt{unstack} \texttt{Series} objects into \texttt{DataFrames}. But
in general \texttt{DataFrame} objects give you a lot of discretion
regarding which columns you want to convert into indices.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}172}]:} \PY{n}{frame} \PY{o}{=} \PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s}{\PYZsq{}}\PY{l+s}{a}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{7}\PY{p}{)}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{b}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{7}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,}
                             \PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{one}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{one}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{one}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{two}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{two}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{two}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{two}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                             \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
          \PY{n}{frame}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}172}]:}    a  b    c  d
          0  0  7  one  0
          1  1  6  one  1
          2  2  5  one  2
          3  3  4  two  0
          4  4  3  two  1
          5  5  2  two  2
          6  6  1  two  3
\end{Verbatim}
        
    You can overload \texttt{set\_index} with more than one column to
produce a hierarchical index using the values of each respective column.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}173}]:} \PY{n}{frame2} \PY{o}{=} \PY{n}{frame}\PY{o}{.}\PY{n}{set\PYZus{}index}\PY{p}{(}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
          \PY{n}{frame2}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}173}]:}        a  b
          c   d      
          one 0  0  7
              1  1  6
              2  2  5
          two 0  3  4
              1  4  3
              2  5  2
              3  6  1
\end{Verbatim}
        
    Crucially, the default \texttt{Pandas} behavior is to remove the indexed
columns. You can force \texttt{Pandas} to keep the old columns by
specifying the \texttt{drop} parameter:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}174}]:} \PY{n}{frame}\PY{o}{.}\PY{n}{set\PYZus{}index}\PY{p}{(}\PY{p}{[}\PY{l+s}{\PYZsq{}}\PY{l+s}{c}\PY{l+s}{\PYZsq{}}\PY{p}{,} \PY{l+s}{\PYZsq{}}\PY{l+s}{d}\PY{l+s}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{n}{drop}\PY{o}{=}\PY{n+nb+bp}{False}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}174}]:}        a  b    c  d
          c   d              
          one 0  0  7  one  0
              1  1  6  one  1
              2  2  5  one  2
          two 0  3  4  two  0
              1  4  3  two  1
              2  5  2  two  2
              3  6  1  two  3
\end{Verbatim}
        
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}175}]:} \PY{n}{frame2}\PY{o}{.}\PY{n}{reset\PYZus{}index}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

            \begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}175}]:}      c  d  a  b
          0  one  0  0  7
          1  one  1  1  6
          2  one  2  2  5
          3  two  0  3  4
          4  two  1  4  3
          5  two  2  5  2
          6  two  3  6  1
\end{Verbatim}
        

    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
